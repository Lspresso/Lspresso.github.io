<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS-系统调用与fork</title>
    <link href="/2022/05/09/OS-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Efork/"/>
    <url>/2022/05/09/OS-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Efork/</url>
    
    <content type="html"><![CDATA[<h1 id="系统调用与fork"><a href="#系统调用与fork" class="headerlink" title="系统调用与fork"></a>系统调用与fork</h1><h3 id="系统调用-System-Call"><a href="#系统调用-System-Call" class="headerlink" title="系统调用(System Call)"></a>系统调用(System Call)</h3><h4 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h4><p>我们先回顾以下几组概念：</p><ol><li>用户态和内核态（也称用户模式和内核模式）： 它们是 CPU 运行的两种状态。根据 lab3 的说明，在 MOS 操作系统实验使用的仿真 R3000 CPU 中，该状态由 CP0 SR 寄存器中 KUc 位的值标志。</li><li>用户空间和内核空间：它们是虚拟内存（进程的地址空间）中的两部分区域。根据 lab2 的说明，MOS 中的用户空间包括 kuseg， 而内核空间主要包括 kseg0 和 kseg1。每个进程的用户空间通常通过页表映射到不同的物理页，而内核空间则直接映射到固定的物理页<a href="https://os.buaa.edu.cn/courses/course-v1:BUAA+B3I062270+2022_SPRING/courseware/e470f921cff34e418655f9480cabce6c/c4329e6bc82b4cbdb60b83647c8c5f86/?child=first#fn1">1</a>以及外部硬件设备。 CPU 在内核态下可以访问任何内存区域，对物理内存等硬件设备有完整的控制权，而在用户态下则只能访问用户空间。</li><li>（用户）进程和内核：进程是资源分配与调度的基本单位，拥有独立的地址空间，而内核负责管理系统资源和调度进程，使进程能够并发运行。 与前两对概念不同，进程和内核并不是对立的存在，可以认为内核是存在于所有进程地址空间中的一段代码。</li></ol><p>系统调用究竟是什么意思呢？我们以下面的程序为例进行讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">Step 1</th><th>用户调用puts函数</th></tr></thead><tbody><tr><td align="center">Step 2</td><td>在一系列的函数调用后，最终调用了write函数</td></tr><tr><td align="center">Step 3</td><td>write函数为寄存器设置了相应的值，并执行了syscall指令</td></tr><tr><td align="center">Step 4</td><td>进入内核态，内核中相应的函数或服务被执行</td></tr><tr><td align="center">Step 5</td><td>回到用户态的write函数中，将结果从相关的寄存器中取回，并返回</td></tr><tr><td align="center">Step 6</td><td>再次经过一系列的返回过程后，回到了puts函数中</td></tr><tr><td align="center">Step 7</td><td>puts函数返回</td></tr></tbody></table><ol><li>存在一些只能由内核来完成的操作（如读写设备、创建进程、IO等）。</li><li>C标准库中一些函数的实现须依赖于操作系统（如我们所探究的puts函数）。</li><li>通过执行syscall指令，用户进程可以陷入到内核态，请求内核提供的服务。</li><li>通过系统调用陷入到内核态时，需要在用户态与内核态之间进行数据传递与保护。</li></ol><p>综合以上内容，我们可以发现，内核将自己所能够提供的服务以系统调用的方式提供给用户空间，以供用户程序完成一些特殊的系统级操作。这样一来，所有的特殊操作就全部在操作系统的掌控之中了，因为用户程序只能将服务相关的参数交予操作系统，而实际完成需要特权的操作是由内核经过重重检查后执行的，所以系统调用可以确保系统的安全性。</p><h3 id="进程间通信机制-IPC"><a href="#进程间通信机制-IPC" class="headerlink" title="进程间通信机制(IPC)"></a>进程间通信机制(IPC)</h3><p>进程间通信机制是微内核最重要的机制之一。IPC机制的实现是我们的系统中不同进程之间有了互相传递消息的能力，为后续实现fork，文件服务系统，管道和shell有很大帮助。</p><ul><li>IPC的目的是使两个进程之间可以通讯</li><li>IPC需要通过系统调用来实现</li><li>IPC还与进程的数据、页面等信息有关</li></ul><p>所谓的通信，可以理解为交换数据。如果我们能将数据由一个进程传递到另一个，那进程就拥有了通信能力。那么实现交换数据所面临的最大的问题，就在于每一个进程的地址空间都是相互独立的，想要传递数据，我们就需要将一个地址空间的东西传递到另一个地址空间。</p><p>如何让两个完全独立的地址空间发生联系呢？答案就是寻找他们是否存在共享部分。虽然地址空间独立，但是有可能被映射到同一物理内存。在env_setup_vm函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>    <span class="hljs-comment">//略去的无关代码</span><br><br>    <span class="hljs-keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="hljs-number">0</span>); i++) &#123;<br>        pgdir[i] = boot_pgdir[i];<br>    &#125;<br>    e-&gt;env_pgdir = pgdir;<br>    e-&gt;env_cr3   = PADDR(pgdir);<br><br>    <span class="hljs-comment">//略去的无关代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现所有进程都共享了内核所在的2G空间，因此我们可以利用共享的内核空间以实现数据的传递。传递的信息可以放在进程控制块中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br>    <span class="hljs-comment">// Lab 4 IPC</span><br>    u_int env_ipc_value;            <span class="hljs-comment">// data value sent to us</span><br>    u_int env_ipc_from;             <span class="hljs-comment">// envid of the sender</span><br>    u_int env_ipc_recving;          <span class="hljs-comment">// env is blocked receiving</span><br>    u_int env_ipc_dstva;            <span class="hljs-comment">// va at which to map received page</span><br>    u_int env_ipc_perm;             <span class="hljs-comment">// perm of page mapping received</span><br>&#125;;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">env_ipc_value</th><th>进程传递的具体数值</th></tr></thead><tbody><tr><td align="center">env_ipc_from</td><td>发送方的进程ID</td></tr><tr><td align="center">env_ipc_recving</td><td>1：等待接受数据中；0：不可接受数据</td></tr><tr><td align="center">env_ipc_dstva</td><td>接收到的页面需要与自身的哪个虚拟页面完成映射</td></tr><tr><td align="center">env_ipc_perm</td><td>传递的页面的权限位设置</td></tr></tbody></table><p>IPC大致流程总结如下</p><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/c9e0dfc9135d81f1e6e78ece6dbd7e6c/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/4-ipc.png" alt="IPC流程图"></p><h3 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h3><h4 id="初窥fork"><a href="#初窥fork" class="headerlink" title="初窥fork"></a>初窥fork</h4><p>fork直译为叉子，在操作系统中更像是分叉的意思，一个进程调用fork()函数后，将从此分叉成两个进程运行，而产生的新进程则称为原进程的子进程。</p><p>对于操作系统，子进程开始运行时的大部分上下文状态与原进程相同，包括程序镜像、通用寄存器和程序计数器 PC 等。 在新的进程中，这一 fork() 调用的返回值为 0，而在旧进程，也就是所谓的父进程中，同一调用的返回值是子进程的进程 ID（MOS 中的 env_id），且一定大于 0。 fork 在父子进程中产生不同返回值这一特性，让我们能够在代码中调用 fork 后判断当前在父进程还是子进程中，以执行不同的后续逻辑，也使父进程能够与子进程进行通信。</p><p>另外，与fork较为相似的是名为exec的一系列系统调用，它会使进程抛弃现有的一切，另起炉灶执行新的进程。</p><h4 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h4><p>在调用fork时，操作系统会为新进程分配独立的虚拟地址空间，但分配独立的地址空间并不意味分配额外物理内存。事实上，新进程仍然使用的时父进程的物理内存。</p><p>但是既然父子进程需要独立并发运行，却又共用物理内存，那么如果父子进程对相同内存进行读写，岂不是会造成数据冲突？</p><p>其实，父子进程共享物理内存有一前提条件：共享的物理内存不会被任意一进程修改。</p><p>那么，对于那些父进程或子进程修改的内存我们又该如何处理呢？ 这里我们引入一个新的概念——写时复制（Copy On Write，简称 COW)。COW 类似于一种对虚拟页的保护机制，通俗来讲就是在 fork 后的父子进程中有<strong>修改</strong>内存（一般是数据段或栈）的行为发生时，内核会捕获到一种<strong>页写入异常</strong>，并在异常处理时为<strong>修改内存的进程</strong>的地址空间中相应地址分配新的物理页面。一般来说，子进程的代码段仍会共享父进程的物理空间，两者的程序镜像也完全相同。在这样的保护下，用户程序可以在行为上认为 fork 时父进程中内存的状态被完整复制到了子进程中，此后父子进程可以独立操作各自的内存。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS 进程和异常</title>
    <link href="/2022/04/18/OS-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/04/18/OS-%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="进程和异常"><a href="#进程和异常" class="headerlink" title="进程和异常"></a>进程和异常</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>进程既是基本的分配单元，也是基本的执行单元。每个进程都是一个实体，有其自己的地址空间，通常包括代码段、数据段和堆栈。程序是一个没有生命的实体，只有被处理器赋予生命时，它才能成为一个活动的实体，而执行中的程序，就是我们所说的进程。</p><p>进程控制块（PCB）是系统专门设置用来管理进程的数据结构。PCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的。</p><p>PCB结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span>       <span class="hljs-comment">// Saved registers </span><br>     LIST_ENTRY(Env) env_link;      <span class="hljs-comment">// Free LIST_ENTRY </span><br>     u_int env_id;                  <span class="hljs-comment">// Unique environment identifier </span><br>     u_int env_parent_id;           <span class="hljs-comment">// env_id of this env&#x27;s parent </span><br>     u_int env_status;              <span class="hljs-comment">// Status of the environment </span><br>     Pde *env_pgdir;                <span class="hljs-comment">// Kernel virtual address of page dir </span><br>     u_int env_cr3; <br>     LIST_ENTRY(Env) env_sched_link; <br>     u_int env_pri;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中Trapframe结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span> <br>    <span class="hljs-comment">/* Saved main processor registers. */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> regs[<span class="hljs-number">32</span>];<br><br>    <span class="hljs-comment">/* Saved special registers. */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_status;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hi;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> lo;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_badvaddr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_cause;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_epc;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc;<br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>env_tf : Trapframe 结构体的定义在include&#x2F;trap.h 中，在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在env_tf变量中。</li><li>env_link : env_link 的机制类似于lab2中的pp_link, 使用它和env_free_list来构造空闲进程链表。</li><li>env_id : 每个进程的env_id 都不一样，它是进程独一无二的标识符。</li><li>env_parent_id : 在之后的实验中，我们将了解到进程是可以被其他进程创建的，创建本进程的进程称为父进程。此变量记录父进程的进程 id，进程之间通过此关联可以形成一棵进程树。</li><li>env_status : 该变量只能有以下三种取值：</li></ul><ol><li><p>ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。</p></li><li><p>ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程需要在一定条件下变成就绪状态从而被CPU调度。（比如因进程通信阻塞时变为 ENV_NOT_RUNNABLE，收到信息后变回 ENV_RUNNABLE）</p></li><li><p>ENV_RUNNABLE : 表明该进程处于<strong>执行状态或就绪状态</strong>，即其可能是正在运行的，也可能正在等待被调度。</p></li></ol><ul><li>env_pgdir : 这个变量保存了该进程页目录的内核虚拟地址。</li><li>env_cr3 : 这个变量保存了该进程页目录的物理地址。</li><li>env_sched_link : 这个变量用来构造调度队列。</li><li>env_pri : 这个变量保存了该进程的优先级。</li></ul><h4 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h4><p>我们知道，电脑在使用的过程中有很多进程同时存在，他们相互独立又相互协作。那么操作系统是如何识别每个系统的呢？</p><p>上文提到，env_id是进程独一无二的标识符。在env.c中，存在一个mkenvid函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">mkenvid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span> &#123;<br>    u_int idx = e - envs;<br>    u_int asid = asid_alloc();<br>    <span class="hljs-keyword">return</span> (asid &lt;&lt; (<span class="hljs-number">1</span> + LOG2NENV)) | (<span class="hljs-number">1</span> &lt;&lt; LOG2NENV) | idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用为创建一个新的进程的id。在函数中调用了asid_alloc函数创建了一个异于当前所有未被释放的进程的 ASID。而asid只是一个int数，为什么要大费周章的去声明，而不是用直接asid++等方式避免冲突呢？</p><p>在学习TLB时我们了解到，进程通过页表访问内存，不同进程的同一个虚拟地址可以映射到多个物理地址。所以显然在Key中不仅要储存控制映射的信息，还要储存识别进程id的信息。TLB 结构的Key Fields（也就是 EntryHi 寄存器）中应用到了 ASID：</p><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/42ebdab497bddb3b310d0dd88eb69a43/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/lab3-asid.svg" alt="TLB对ASID的规定"></p><p>可以看到，ASID仅占有6位，如果单纯依靠自增操作很快就会发生溢出。</p><p>在asid_alloc函数中时如何避免这一问题的呢？具体实现是通过位图法管理可用的 64 个 ASID，如果当 ASID 耗尽时仍要创建进程，系统会 panic。</p><h4 id="设置进程控制块"><a href="#设置进程控制块" class="headerlink" title="设置进程控制块"></a>设置进程控制块</h4><p>进程创建流程：</p><ul><li>从env_free_list链表中索取一个空闲PCB块</li><li>手动设置进程信息</li><li>为新进程分配资源，为新进程的程序和数据以及用户栈分配必要的内存空间。</li><li>从空闲链表中取出该PCB块</li></ul><p>在编写初始化新进程的地址空间的函数env_setup_vm时，涉及到了一些宏定义如UTOP,VPT,UVPT等其代表含义如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">/<span class="hljs-symbol">*</span><br> o     4G -----------&gt;  +----------------------------+------------0x100000000<br> o                      |<span class="hljs-string">       ...                  </span>|<span class="hljs-string">  kseg3</span><br><span class="hljs-string"> o                      +----------------------------+------------0xe000 0000</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">       ...                  </span>|<span class="hljs-string">  kseg2</span><br><span class="hljs-string"> o                      +----------------------------+------------0xc000 0000</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">   Interrupts &amp; Exception   </span>|<span class="hljs-string">  kseg1</span><br><span class="hljs-string"> o                      +----------------------------+------------0xa000 0000</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">      Invalid memory        </span>|<span class="hljs-string">   /</span>|<span class="hljs-string">\</span><br><span class="hljs-string"> o                      +----------------------------+----</span>|<span class="hljs-string">-------Physics Memory Max</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">       ...                  </span>|<span class="hljs-string">  kseg0</span><br><span class="hljs-string"> o  VPT,KSTACKTOP-----&gt; +----------------------------+----</span>|<span class="hljs-string">-------0x8040 0000-------end</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">       Kernel Stack         </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> KSTKSIZE            /</span>|<span class="hljs-string">\</span><br><span class="hljs-string"> o                      +----------------------------+----</span>|<span class="hljs-string">------                </span>|<br> o                      |<span class="hljs-string">       Kernel Text          </span>|<span class="hljs-string">    </span>|<span class="hljs-string">                    PDMAP</span><br><span class="hljs-string"> o      KERNBASE -----&gt; +----------------------------+----</span>|<span class="hljs-string">-------0x8001 0000    </span>|<br> o                      |<span class="hljs-string">   Interrupts &amp; Exception   </span>|<span class="hljs-string">   \</span>|<span class="hljs-string">/                    \</span>|<span class="hljs-string">/</span><br><span class="hljs-string"> o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">         User VPT           </span>|<span class="hljs-string">     PDMAP                /</span>|<span class="hljs-string">\</span><br><span class="hljs-string"> o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span>|<br> o                      |<span class="hljs-string">         PAGES              </span>|<span class="hljs-string">     PDMAP                 </span>|<br> o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |<span class="hljs-string"></span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">         ENVS               </span>|<span class="hljs-string">     PDMAP                 </span>|<br> o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |<span class="hljs-string"></span><br><span class="hljs-string"> o  UXSTACKTOP -/       </span>|<span class="hljs-string">     user exception stack   </span>|<span class="hljs-string">     BY2PG                 </span>|<br> o                      +----------------------------+------------0x7f3f f000    |<span class="hljs-string"></span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">       Invalid memory       </span>|<span class="hljs-string">     BY2PG                 </span>|<br> o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |<span class="hljs-string"></span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">     normal user stack      </span>|<span class="hljs-string">     BY2PG                 </span>|<br> o                      +----------------------------+------------0x7f3f d000    |<span class="hljs-string"></span><br><span class="hljs-string"> a                      </span>|<span class="hljs-string">                            </span>|<span class="hljs-string">                           </span>|<br> a                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |<span class="hljs-string"></span><br><span class="hljs-string"> a                      .                            .                           </span>|<br> a                      .                            .                         kuseg<br> a                      .                            .                           |<span class="hljs-string"></span><br><span class="hljs-string"> a                      </span>|<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<span class="hljs-string">                           </span>|<br> a                      |<span class="hljs-string">                            </span>|<span class="hljs-string">                           </span>|<br> o       UTEXT   -----&gt; +----------------------------+                           |<span class="hljs-string"></span><br><span class="hljs-string"> o                      </span>|<span class="hljs-string">                            </span>|<span class="hljs-string">     2 * PDMAP            \</span>|<span class="hljs-string">/</span><br><span class="hljs-string"> a     0 ------------&gt;  +----------------------------+ -----------------------------</span><br><span class="hljs-string"> o</span><br><span class="hljs-string">*/</span><br></code></pre></td></tr></table></figure><p>PDX()函数用于取页目录项的下标。</p><p>在设置完第二步之后，应当设置SR(Status Register)，即env-&gt;env_tf.cp0_status。</p><p>SR 寄存器的低六位是一个二重栈的结构。KUo 和 IEo 是一组，每当中断发生的时候，硬件自动会将 KUp 和 IEp 的数值拷贝到这里；KUp 和 IEp 是一组，当中断发生的时候，硬件会把 KUc 和 IEc 的数值拷贝到这里。其中KU 表示是否位于内核模式下，为1 表示位于内核模式下；IE 表示中断是否开启，为1 表示开启，否则不开启。</p><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/5ea075b45aaaa9f615d28fb2bd0cb342/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/3-R3000_SR.png" alt="R3000的SR寄存器示意图"></p><h4 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h4><p>在上文创建进程的第三步提到，为新进程的程序分配空间存放代码，需要用到load_icode_mapper函数和load_elf函数。</p><p>ELF文件一般以两种形式出现，一种是组成可重定位文件，一种是组成可执行文件或可被共享的对象文件。在这里 ELF 文件以后者的形式出现，用于在内存中构建进程映像。</p><p>要想正确加载一个ELF 文件到内存，只需将ELF 文件中所有需要加载的segment 加载到对应的虚地址上即可。</p><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>创建进程过程比较简单，就是对上述部分函数进行封装，分配一个新的ENV结构体，设置进程控制块，之后将二进制代码载入对应地址空间即可。</p><p>一种宏定义的使用方式：##代表拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONS(a,b) int(a##e##b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, CONS(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// 2e3 输出:2000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进程运行与切换"><a href="#进程运行与切换" class="headerlink" title="进程运行与切换"></a>进程运行与切换</h4><p>env_run，是进程运行使用的基本函数，它包括两部分：</p><ul><li><p>保存当前进程上下文**(如果当前没有运行的进程就跳过这一步)**</p></li><li><p>恢复要启动的进程的上下文，然后运行该进程。</p></li></ul><p>在这里提到的运行新进程并不只是代表运行进程，而是同时包括了进程的切换，使进程停止并运行另一个进程。这就要求我们保存当前进程的相关信息。</p><p>那么这些信息都是什么呢？其一是进程本身信息，其二是进程周围的环境信息。</p><p>事实上，进程本身信息如env_id，env_cr3等保留在原本的进程控制块中，根本不会改变，也就无须保存。我们仅需保存会发生变化的进程周围的环境信息即可。</p><p>所以env_run函数的执行流程为：</p><ol><li>保存当前进程的上下文信息，设置当前进程上下文中的 pc 为epc。</li><li>切换 curenv 为即将运行的进程。</li><li>调用 lcontext 函数，设置全局变量mCONTEXT为当前进程页目录地址，这个值将在TLB重填时用到。</li><li>调用 env_pop_tf 函数，恢复现场、异常返回。</li></ol><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>CPU不仅有常用的32个寄存器，还有功能广泛的协处理器。其中，中断异常用到了控制寄存器CP0，这里的CP0指的是编号为12，13，14的三个CP0寄存器</p><table><thead><tr><th>寄存器助记符</th><th>CP0寄存器编号</th><th>描述</th></tr></thead><tbody><tr><td>SR</td><td>12</td><td>状态寄存器，包括中断引脚使能，其他 CPU 模式等位域</td></tr><tr><td>Cause</td><td>13</td><td>记录导致异常的原因</td></tr><tr><td>EPC</td><td>14</td><td>异常结束后程序恢复执行的位置</td></tr></tbody></table><p>在《See MIPS Run Linux》的第五章中中介绍到，MIPS CPU 处理一个异常时大致要完成四项工作：</p><ol><li>设置 EPC 指向异常结束时重新返回的地址。</li><li>设置 SR 位，强制 CPU 进入内核态（行驶更高级的特权）并禁止中断。</li><li>设置 Cause 寄存器，用于记录异常发生的原因。</li><li>CPU 开始从异常入口位置取指，此后一切交给软件处理。</li></ol><h4 id="异常的分发"><a href="#异常的分发" class="headerlink" title="异常的分发"></a>异常的分发</h4><p>当发生异常时，处理器就会进入一个用于分发异常的程序，这个程序的作用就是检测发生了哪种异常，并调用相应的异常处理程序。</p><p>异常分发代码处理过程如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.section</span> <span class="hljs-meta">.text</span>.exc_vec3<br>NESTED(except_vec3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sp</span>)<br>    <span class="hljs-meta">.set</span> noat <br>    <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span><span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">mfc0 </span><span class="hljs-built_in">k1</span>,CP0_CAUSE<br>    la <span class="hljs-built_in">k0</span>,exception_handlers<br>    <span class="hljs-keyword">andi </span><span class="hljs-built_in">k1</span>,<span class="hljs-number">0x7c</span><br>    <span class="hljs-keyword">addu </span><span class="hljs-built_in">k0</span>,<span class="hljs-built_in">k1</span><br>    <span class="hljs-keyword">lw </span><span class="hljs-built_in">k0</span>,(<span class="hljs-built_in">k0</span>)<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">jr </span><span class="hljs-built_in">k0</span><br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>END(except_vec3)<br><span class="hljs-meta">.set</span> <span class="hljs-built_in">at</span><br></code></pre></td></tr></table></figure><h4 id="异常向量组"><a href="#异常向量组" class="headerlink" title="异常向量组"></a>异常向量组</h4><p>异常分发程序通过exception_handlers数组定位中断处理程序，而exception_handlers称作异常向量组。</p><p><strong>0 号异常</strong>的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成<br><strong>1 号异常</strong>的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读<br><strong>2 号异常</strong>的处理函数为handle_tlb，TLB 异常，TLB 中没有和程序地址匹配的有效入口<br><strong>3 号异常</strong>的处理函数为handle_tlb，TLB 异常，TLB 失效，且未处于异常模式（用于提高处理效率）<br><strong>8 号异常</strong>的处理函数为handle_sys，系统调用，陷入内核，执行了 syscall 指令</p><h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><p>从 CPU 到操作系统中关于中断处理的普遍性流程如下</p><ol><li>将当前 PC 地址存入 CP0 中的 EPC 寄存器。</li><li>将 IEc,KUc 拷贝至 KUp 和IEp 中，同时将 IEc 置为 0，表示关闭全局中断使能，将 KUc 置 1，表示处于内核态。</li><li>在 Cause 寄存器中，保存 ExcCode 段。由于此处是中断异常，对应的异常码即为 0。</li><li>PC 转入异常分发程序入口。</li><li>通过异常分发，判断出当前异常为中断异常，随后进入相应的中断处理程序。在MOS 中即对应 handle_int 函数。</li><li>在中断处理程序中进一步判断 CP0_CAUSE 寄存器中是由几号中断位引发的中断，然后进入不同中断对应的中断服务函数。</li><li>中断处理完成，将 EPC 的值取出到 PC 中，恢复 SR 中相应的中断使能，继续执行。</li></ol><p>时钟中断和操作系统的时间片轮转算法密切相关。时间片轮转算法是将每个进程分配一个时间段，即为该进程允许运行时间，如果在时间片结束时进程还未运行完毕，则挂起并执行另一进程。而CPU通过定时器产生的时钟中断知晓进程结束。</p><p>当时钟中断产生，当前进程挂起，就需要寻找一合适进程运行。</p><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>前文提到，当时钟中断产生，就需要寻找一合适进程运行。这就涉及到进程调度，而调度算法就是时间片轮转的算法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博弈与社会导论</title>
    <link href="/2022/04/17/%E5%8D%9A%E5%BC%88%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%AF%BC%E8%AE%BA/"/>
    <url>/2022/04/17/%E5%8D%9A%E5%BC%88%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博弈与社会导论"><a href="#博弈与社会导论" class="headerlink" title="博弈与社会导论"></a>博弈与社会导论</h1><h3 id="什么是博弈"><a href="#什么是博弈" class="headerlink" title="什么是博弈"></a>什么是博弈</h3><p><strong>从选择说起</strong></p><p>所有有意义的人的行为都可以称为人的选择行为。凡是选择必有成本，一个选择的成本就在于因为选择了所选择的而放弃的可能选择，经济学上称这样的成本为“机会成本”。</p><p>经济学是关于选择、权衡和机会成本的学科。在讨论一般均衡和竞争性市场中的微观主体选择时，每个主体都是单独决策的，但是在现实中，我们无法在不考虑其他人反应的情况下去做出自己的选择。</p><p>因此，如果市场理论是关于在一定市场条件下个体如何做出选择的理论，那么，博弈论则是关于在一定的博弈框架之下<strong>策略性相互依存的</strong>个体如何做出选择的理论。</p><p>“囚徒困境”是一个经典的博弈论案例。</p><p>两个囚徒被单独看守，他们可以选择坦白与抗拒。如果两人都抗拒，两人只会被拘留一小段时间；如果一人坦白一人抗拒，那么坦白者释放，抗拒者从严处罚入狱；如果两人都坦白，那么两人都入狱。</p><table><thead><tr><th></th><th></th><th>乙</th><th>乙</th></tr></thead><tbody><tr><td></td><td></td><td>坦白</td><td>抗拒</td></tr><tr><td>甲</td><td>坦白</td><td>-6，-6</td><td>0，-8</td></tr><tr><td>甲</td><td>抗拒</td><td>-8，0</td><td>-1，-1</td></tr></tbody></table><p>只要囚徒是理性的，他都会选择坦白。</p><p>囚徒困境问题的选择结果并不是我们想要讨论的重点，我们其实想要通过这一问题引出另一个问题，即个体理性与集体理性之间存在的冲突。所谓“机会主义”，可以概括为：人们一边呼吁着合作，又一边小心地寻找着占便宜的机会。</p><p>囚徒困境是一个典型的“博弈 (game，也作‘对策’)”：若干参与人 (players) 如同正共同置身于一场游戏或者棋局之中，游戏最终走向何种结局 (outcome)，每名参与人在这一结局下获得怎样的支付 (payoff)，不仅取决于每名参与人自身的选择，也取决于其他参与人的选择。</p><p>囚徒困境问题展示的，是一名参与人的最佳选择是什么，一般情况下依赖于其他参与人的选择是什么，这就是参与人之间是是“<strong>策略性相互依存的</strong> (strategically interdependent)”。</p><p>一般情况下，均衡指一个系统达到相对稳定的状态。个体选择行为存在均衡，这种均衡就是在给定的外部条件下，个体所能做出的对自己最优的选择。</p><p>而博弈弈的均衡则要求在给定的博弈规则的约束下，多人选择系统达到稳定的状态。</p><h3 id="社会基本问题"><a href="#社会基本问题" class="headerlink" title="社会基本问题"></a>社会基本问题</h3><p>社会问题的重点是：人与人的目标不同，认识各异，如何尽可能地避免冲突与损失，实现社会的“最优”目标。</p><p>因此，目标不同的个人之见的协调与合作，是任何一个社会的基本问题。诸如形成一致预期、建立可行承诺机制一类的方法，对于实现不同社会个体之间的协调与合作具有关键的意义。</p><p>评价社会选择结果的标准是什么？这一问题显然要比评价个人选择结果的标准复杂得多 —— 评价社会选择结果的标准应该具有某种共同性。目前最重要、最主流的两种社会选择评价标准是Pareto标准和Kaldor-Hicks标准。</p><h3 id="博弈与社会"><a href="#博弈与社会" class="headerlink" title="博弈与社会"></a>博弈与社会</h3><p>显然，博弈论并非是博弈论研究者的“创造”，而是存在于社会的各个角落，历史的各个时期。</p><p>我们在下班后去菜市场买菜和大妈砍价是一种博弈，项羽破釜沉舟百二秦川终属楚也是一种博弈。</p><p>社会即是博弈，决定了我们应该在博弈中理解社会。不论社会制度还是社会组织，都是所有社会成员共同选择的结果。因此，我们不应抽象的 (或者先验的) 讨论其合理性的问题，而应将其视为社会成员博弈的“均衡结果”来加以认识。</p><p>关键，在于以博弈均衡的视角，理解现实社会制度和社会组织，将其视为<strong>许多社会主体相互作用和共同选择的结果</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS 内存管理</title>
    <link href="/2022/04/13/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/04/13/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="虚拟地址到物理地址映射"><a href="#虚拟地址到物理地址映射" class="headerlink" title="虚拟地址到物理地址映射"></a>虚拟地址到物理地址映射</h3><p>R3000 CPU只会发出虚拟地址，通过虚拟地址映射到物理地址，随后通过物理地址访存。</p><table><thead><tr><th align="center">虚拟地址</th><th align="center">映射方式</th><th align="center">访存方式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">0x80000000~0x9fffffff (kseg0)</td><td align="center">最高位置零</td><td align="center">cache</td><td align="center">存放内核代码、数据结构</td></tr><tr><td align="center">0xa0000000~0xbfffffff (kseg1)</td><td align="center">最高三位置零</td><td align="center">不通过chche</td><td align="center">映射外设</td></tr><tr><td align="center">0x00000000~0x7fffffff (kuseg)</td><td align="center">TLB</td><td align="center">cache</td><td align="center"></td></tr></tbody></table><p>MMU(Memory Management Unit)，内存管理单元。</p><p>在R3000中，使用MMU完成上述转换，在MMU中采用硬件TLB完成地址映射。所有的在低2GB空间的访存操作都经过TLB。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>在main.c中，调用了mips_init()函数，该函数的实现在init.c中，进入init.c，我们可以看到依次调用了五个函数，mips_detect_memory, mips_vm_init, page_init, physical_memory_manage_check, page_check</p><p>顾名思义，前三个用于初始化，后两个用于检查正确性</p><p>mips_detect_memory()</p><p>内存相关初始化</p><ul><li>maxpa: max physical address</li><li>basemem: base memory，物理内存对应字节数</li><li>npage: 总物理页数</li><li>extmem: extend memory</li></ul><p>mips_vm_init()</p><ul><li>alloc: 该函数调用了alloc函数，作用是分配n字节空间并返回初始虚拟地址，并保证align可以整除虚拟地址，若 clear 为真则将对应空间的值清零，否则不清零。</li></ul><p>page_init()</p><p>初始化Pages结构体和空闲链表</p><h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><p>链表宏</p><p>在MOS中对链表相关进行了宏封装，在pmap.h中可以看到，Page结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>Page_LIST_entry_t pp_link;<br>u_short pp_ref;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>pp_ref</code> 对应这一页物理内存被引用的次数，它等于有多少虚拟页映射到该物理页。<code>Page_LIST_entry_t</code>是一个特殊的类型，它定义为<code>LIST_ENTRY(Page)</code>，而<code>LIST_ENTRY(Page)</code>本质是一个链表项，我们可以看做<code>pp_link</code>是另一个结构体，包含指向下一个元素的指针 <code>le_next</code>，以及指向前一个元素链表项 <code>le_next</code> 的指针 <code>le_prev</code>。</p><p>我们在queue.h中找到LIST_ENTRY的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                    \</span><br><span class="hljs-meta">        struct &#123;                                                                \</span><br><span class="hljs-meta">                struct type *le_next;   <span class="hljs-comment">/* next element */</span>                      \</span><br><span class="hljs-meta">                struct type **le_prev;  <span class="hljs-comment">/* address of previous next element */</span>  \</span><br><span class="hljs-meta">        &#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们Page的本质是一个结构体，其中属性为另一个结构体pp_link和一个u_short类型的pp_ref。</p><p>queue.h中宏定义的部分函数如下</p><ul><li><code>LIST_HEAD(name, type)</code>，创建一个名称为 <code>name</code> 链表的头部结构体， 包含一个指向 <code>type</code> 类型结构体的指针，这个指针可以指向链表的首个元素。</li><li><code>LIST_ENTRY(type)</code>，作为一个特殊的「类型」出现，它的本质是一个链表项，包括指向下一个元素的指针 <code>le_next</code>，以及指向前一个元素链表项 <code>le_next</code> 的指针 <code>le_prev</code>。 <code>le_prev</code> 是一个指针的指针，它的作用是当删除一个元素时，更改前一个元素链表项的 <code>le_next</code>。</li><li><code>LIST_EMPTY(head)</code>，判断头部结构体 <code>head</code> 对应的链表是否为空。</li><li><code>LIST_FIRST(head)</code>，将返回头部结构体 <code>head</code> 对应的链表的首个元素。</li><li><code>LIST_INIT(head)</code> 是将头部结构体 <code>head</code> 对应的链表初始化，等价于将首个元素清空。</li><li><code>LIST_NEXT(elm, field)</code>，结构体 <code>elm</code> 包含的名为 <code>field</code> 的数据，类型是一个链表项 <code>LIST_ENTRY(type)</code>， 返回其指向的下一个元素。下面出现的 <code>field</code> 含义均和此相同。</li><li><code>LIST_INSERT_AFTER(listelm, elm, field)</code>，将 <code>elm</code> 插到已有元素 <code>listelm</code> 之后。</li><li><code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，将 <code>elm</code> 插到已有元素 <code>listelm</code> 之前。</li><li><code>LIST_INSERT_HEAD(head, elm, field)</code>，将 <code>elm</code> 插到头部结构体 <code>head</code> 对应链表的头部。</li><li><code>LIST_INSERT_TAIL(head, elm, field)</code>，将 <code>elm</code> 插到头部结构体 <code>head</code> 对应链表的尾部。</li><li><code>LIST_REMOVE(elm, field)</code>，将 <code>elm</code> 从对应链表中删除。</li></ul><p>通过上述宏，我们可以得到一个该链表的大致结构</p><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/60774e7e67cd95f6231c8bd20378469a/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/lab2-macro-list.svg" alt="lab2-macro-list.svg"></p><p>那么有意思的问题来了，我们曾经见过的双向链表，都是一个指针next指向后一个节点，一个指针prev指向前一个节点，为什么在此次定义中，le_prev指针却是指向上一个指针的le_next指针呢？</p><p>我们可以理解，这样设计同样可以实现插入，删除等操作，但是为什么要这么设计而不采用常规设计呢？</p><p>这是出于性能优化考虑，node-&gt;prev-&gt;next相比于node-&gt;prev_next要多进行一次offest的计算，明白了这一点，就不难理解这一设定了。</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>TLB(translation lookaside buffer)，快表，当cpu要访问一个虚拟地址&#x2F;线性地址时，CPU会首先根据虚拟地址的高20位（20是x86特定的，不同架构有不同的值）在TLB中查找。如果是表中没有相应的表项，称为TLB miss，需要通过访问慢速RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以后对同一线性地址的访问，直接从TLB表项中获取物理地址即可，称为TLB hit。</p><p>听起来和我们在计算机组成原理中学过的cache十分相似，事实上，我们可以把TLB看作位于内存中的页表的cahce。</p><p><strong>TLB硬件结构</strong></p><p>每一个 TLB 表项都有 64 位，其中高 32 位是 Key，低 32 位是 Data。</p><p>EntryHi、EntryLo都是CP0中的寄存器，分别对应TLB的Key与Data，二者结构如下</p><p>Key（EntryHi）</p><ul><li><p>VPN：Virtual Page Number</p><ul><li>当 <strong>TLB</strong> 缺失（CPU 发出虚拟地址，欲在 TLB 中查找物理地址但未查到）时，<strong>EntryHi</strong> 中的 <strong>VPN</strong> 自动（由硬件）填充为对应虚拟地址的虚页号。 </li><li>当需要填充或检索 TLB 表项时，软件需要将 VPN 段填充为对应的虚拟地址</li></ul></li><li><p>ASID：Address Space IDentifier</p><ul><li>用于区分不同的地址空间。查找 <strong>TLB</strong> 表项时，除了需要提供 <strong>VPN</strong>，还需要提供 <strong>ASID</strong>（同一虚拟地址在不同的地址空间中通常映射到不同的物理地址）。</li></ul></li></ul><p>Data（EntryLo）</p><ul><li>PFN：Physical Frame Number<ul><li>软件通过填写 <strong>PFN</strong>，随后使用 <strong>TLB</strong> 写指令，才将此时的 <strong>Key</strong> 与 <strong>Data</strong>写入 <strong>TLB</strong> 中。</li></ul></li><li>N：Non-cachable。当该位置高时，后续的物理地址访存将不通过 cache。 </li><li>D：Dirty。事实上是可写位。当该位置高时，该地址可写；否则任何写操作都将引发 TLB 异常。</li><li>V：Valid。如果该位为低，则任何访问该地址的操作都将引发 TLB 异常。</li><li>G：Global。</li></ul><p>事实上，TLB构建了一个映射，&lt; VPN*,* ASID &gt;→&lt; PFN*,* N*,* D*,* V*,* G &gt;</p><p><strong>软件操作TLB的流程</strong></p><ol><li><p>填写 CP0 寄存器。</p></li><li><p>使用 TLB 相关指令。</p></li></ol><h3 id="多级页表与页目录自映射"><a href="#多级页表与页目录自映射" class="headerlink" title="多级页表与页目录自映射"></a>多级页表与页目录自映射</h3><p>如果页表与页目录没有被映射到进程的地址空间，4GB的地址空间均映射到进程内存需要4MB空间存放页表，4KB空间存放页目录。</p><p>在MOS中，页表和页目录都得到了映射，也就是说，在1024个页表之中有一个页表所对应的4MB是这1024个页表所占用的空间。而这一特殊页表就是页目录，因此，只需要4MB即可容纳页表和页目录。</p><p><strong>自映射目录的页目录项的地址</strong></p><p>在MOS中，将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000（共4MB）区域，这4MB的起始位置对应着页目录第一个页目录项，0x7fc00000这一地址对应第（0x7fc00000 &gt;&gt; 12）个页表项，该页表项相对于页表基地址的偏移为（0x7fc00000 &gt;&gt; 12）* 4，即0x1ff000，故页目录基地址为0x7fdff000。该项对应第（0x1ff000 &gt;&gt; 12）个页目录项，相对于页目录基地址为（0x1ff000 &gt;&gt; 12）* 4，即0x7fdff7fc。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/11/hello-world/"/>
    <url>/2022/04/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
