<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博弈与社会导论</title>
    <link href="/2022/04/17/%E5%8D%9A%E5%BC%88%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%AF%BC%E8%AE%BA/"/>
    <url>/2022/04/17/%E5%8D%9A%E5%BC%88%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博弈与社会导论"><a href="#博弈与社会导论" class="headerlink" title="博弈与社会导论"></a>博弈与社会导论</h1><h3 id="什么是博弈"><a href="#什么是博弈" class="headerlink" title="什么是博弈"></a>什么是博弈</h3><p><strong>从选择说起</strong></p><p>​所有有意义的人的行为都可以称为人的选择行为。凡是选择必有成本，一个选择的成本就在于因为选择了所选择的而放弃的可能选择，经济学上称这样的成本为“机会成本”。</p><p>​经济学是关于选择、权衡和机会成本的学科。在讨论一般均衡和竞争性市场中的微观主体选择时，每个主体都是单独决策的，但是在现实中，我们无法在不考虑其他人反应的情况下去做出自己的选择。</p><p>​因此，如果市场理论是关于在一定市场条件下个体如何做出选择的理论，那么，博弈论则是关于在一定的博弈框架之下<strong>策略性相互依存的</strong>个体如何做出选择的理论。</p><p>​“囚徒困境”是一个经典的博弈论案例。</p><p>两个囚徒被单独看守，他们可以选择坦白与抗拒。如果两人都抗拒，两人只会被拘留一小段时间；如果一人坦白一人抗拒，那么坦白者释放，抗拒者从严处罚入狱；如果两人都坦白，那么两人都入狱。</p><p><img src="C:\Users\asdcxz\Desktop\图片1.png" alt="图片1"></p><p>只要囚徒是理性的，他都会选择坦白。</p><p>​囚徒困境问题的选择结果并不是我们想要讨论的重点，我们其实想要通过这一问题引出另一个问题，即个体理性与集体理性之间存在的冲突。所谓“机会主义”，可以概括为：人们一边呼吁着合作，又一边小心地寻找着占便宜的机会。</p><p>​囚徒困境是一个典型的“博弈 (game，也作‘对策’)”：若干参与人 (players) 如同正共同置身于一场游戏或者棋局之中，游戏最终走向何种结局 (outcome)，每名参与人在这一结局下获得怎样的支付 (payoff)，不仅取决于每名参与人自身的选择，也取决于其他参与人的选择。</p><p>​囚徒困境问题展示的，是一名参与人的最佳选择是什么，一般情况下依赖于其他参与人的选择是什么，这就是参与人之间是是“<strong>策略性相互依存的</strong> (strategically interdependent)”。</p><p>​一般情况下，均衡指一个系统达到相对稳定的状态。个体选择行为存在均衡，这种均衡就是在给定的外部条件下，个体所能做出的对自己最优的选择。</p><p>​而博弈弈的均衡则要求在给定的博弈规则的约束下，多人选择系统达到稳定的状态。</p><h3 id="社会基本问题"><a href="#社会基本问题" class="headerlink" title="社会基本问题"></a>社会基本问题</h3><p>​社会问题的重点是：人与人的目标不同，认识各异，如何尽可能地避免冲突与损失，实现社会的“最优”目标。</p><p>​因此，目标不同的个人之见的协调与合作，是任何一个社会的基本问题。诸如形成一致预期、建立可行承诺机制一类的方法，对于实现不同社会个体之间的协调与合作具有关键的意义。</p><p>​评价社会选择结果的标准是什么？这一问题显然要比评价个人选择结果的标准复杂得多 —— 评价社会选择结果的标准应该具有某种共同性。目前最重要、最主流的两种社会选择评价标准是Pareto标准和Kaldor-Hicks标准。</p><h3 id="博弈与社会"><a href="#博弈与社会" class="headerlink" title="博弈与社会"></a>博弈与社会</h3><p>​显然，博弈论并非是博弈论研究者的“创造”，而是存在于社会的各个角落，历史的各个时期。</p><p>​我们在下班后去菜市场买菜和大妈砍价是一种博弈，项羽破釜沉舟百二秦川终属楚也是一种博弈。</p><p>​社会即是博弈，决定了我们应该在博弈中理解社会。不论社会制度还是社会组织，都是所有社会成员共同选择的结果。因此，我们不应抽象的 (或者先验的) 讨论其合理性的问题，而应将其视为社会成员博弈的“均衡结果”来加以认识。</p><p>​关键，在于以博弈均衡的视角，理解现实社会制度和社会组织，将其视为<strong>许多社会主体相互作用和共同选择的结果</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS 内存管理</title>
    <link href="/2022/04/13/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/04/13/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="虚拟地址到物理地址映射"><a href="#虚拟地址到物理地址映射" class="headerlink" title="虚拟地址到物理地址映射"></a>虚拟地址到物理地址映射</h3><p>R3000 CPU只会发出虚拟地址，通过虚拟地址映射到物理地址，随后通过物理地址访存。</p><table><thead><tr><th align="center">虚拟地址</th><th align="center">映射方式</th><th align="center">访存方式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">0x80000000~0x9fffffff (kseg0)</td><td align="center">最高位置零</td><td align="center">cache</td><td align="center">存放内核代码、数据结构</td></tr><tr><td align="center">0xa0000000~0xbfffffff (kseg1)</td><td align="center">最高三位置零</td><td align="center">不通过chche</td><td align="center">映射外设</td></tr><tr><td align="center">0x00000000~0x7fffffff (kuseg)</td><td align="center">TLB</td><td align="center">cache</td><td align="center"></td></tr></tbody></table><p>MMU(Memory Management Unit)，内存管理单元。</p><p>在R3000中，使用MMU完成上述转换，在MMU中采用硬件TLB完成地址映射。所有的在低2GB空间的访存操作都经过TLB。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>在main.c中，调用了mips_init()函数，该函数的实现在init.c中，进入init.c，我们可以看到依次调用了五个函数，mips_detect_memory, mips_vm_init, page_init, physical_memory_manage_check, page_check</p><p>顾名思义，前三个用于初始化，后两个用于检查正确性</p><p>mips_detect_memory()</p><p>内存相关初始化</p><ul><li>maxpa: max physical address</li><li>basemem: base memory，物理内存对应字节数</li><li>npage: 总物理页数</li><li>extmem: extend memory</li></ul><p>mips_vm_init()</p><ul><li>alloc: 该函数调用了alloc函数，作用是分配n字节空间并返回初始虚拟地址，并保证align可以整除虚拟地址，若 clear 为真则将对应空间的值清零，否则不清零。</li></ul><p>page_init()</p><p>初始化Pages结构体和空闲链表</p><h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><p>链表宏</p><p>在MOS中对链表相关进行了宏封装，在pmap.h中可以看到，Page结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>Page_LIST_entry_t pp_link;<br>u_short pp_ref;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>pp_ref</code> 对应这一页物理内存被引用的次数，它等于有多少虚拟页映射到该物理页。<code>Page_LIST_entry_t</code>是一个特殊的类型，它定义为<code>LIST_ENTRY(Page)</code>，而<code>LIST_ENTRY(Page)</code>本质是一个链表项，我们可以看做<code>pp_link</code>是另一个结构体，包含指向下一个元素的指针 <code>le_next</code>，以及指向前一个元素链表项 <code>le_next</code> 的指针 <code>le_prev</code>。</p><p>我们在queue.h中找到LIST_ENTRY的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                    \</span><br><span class="hljs-meta">        struct &#123;                                                                \</span><br><span class="hljs-meta">                struct type *le_next;   <span class="hljs-comment">/* next element */</span>                      \</span><br><span class="hljs-meta">                struct type **le_prev;  <span class="hljs-comment">/* address of previous next element */</span>  \</span><br><span class="hljs-meta">        &#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们Page的本质是一个结构体，其中属性为另一个结构体pp_link和一个u_short类型的pp_ref。</p><p>queue.h中宏定义的部分函数如下</p><ul><li><code>LIST_HEAD(name, type)</code>，创建一个名称为 <code>name</code> 链表的头部结构体， 包含一个指向 <code>type</code> 类型结构体的指针，这个指针可以指向链表的首个元素。</li><li><code>LIST_ENTRY(type)</code>，作为一个特殊的「类型」出现，它的本质是一个链表项，包括指向下一个元素的指针 <code>le_next</code>，以及指向前一个元素链表项 <code>le_next</code> 的指针 <code>le_prev</code>。 <code>le_prev</code> 是一个指针的指针，它的作用是当删除一个元素时，更改前一个元素链表项的 <code>le_next</code>。</li><li><code>LIST_EMPTY(head)</code>，判断头部结构体 <code>head</code> 对应的链表是否为空。</li><li><code>LIST_FIRST(head)</code>，将返回头部结构体 <code>head</code> 对应的链表的首个元素。</li><li><code>LIST_INIT(head)</code> 是将头部结构体 <code>head</code> 对应的链表初始化，等价于将首个元素清空。</li><li><code>LIST_NEXT(elm, field)</code>，结构体 <code>elm</code> 包含的名为 <code>field</code> 的数据，类型是一个链表项 <code>LIST_ENTRY(type)</code>， 返回其指向的下一个元素。下面出现的 <code>field</code> 含义均和此相同。</li><li><code>LIST_INSERT_AFTER(listelm, elm, field)</code>，将 <code>elm</code> 插到已有元素 <code>listelm</code> 之后。</li><li><code>LIST_INSERT_BEFORE(listelm, elm, field)</code>，将 <code>elm</code> 插到已有元素 <code>listelm</code> 之前。</li><li><code>LIST_INSERT_HEAD(head, elm, field)</code>，将 <code>elm</code> 插到头部结构体 <code>head</code> 对应链表的头部。</li><li><code>LIST_INSERT_TAIL(head, elm, field)</code>，将 <code>elm</code> 插到头部结构体 <code>head</code> 对应链表的尾部。</li><li><code>LIST_REMOVE(elm, field)</code>，将 <code>elm</code> 从对应链表中删除。</li></ul><p>通过上述宏，我们可以得到一个该链表的大致结构</p><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/60774e7e67cd95f6231c8bd20378469a/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/lab2-macro-list.svg" alt="lab2-macro-list.svg"></p><p>那么有意思的问题来了，我们曾经见过的双向链表，都是一个指针next指向后一个节点，一个指针prev指向前一个节点，为什么在此次定义中，le_prev指针却是指向上一个指针的le_next指针呢？</p><p>我们可以理解，这样设计同样可以实现插入，删除等操作，但是为什么要这么设计而不采用常规设计呢？</p><p>这是出于性能优化考虑，node-&gt;prev-&gt;next相比于node-&gt;prev_next要多进行一次offest的计算，明白了这一点，就不难理解这一设定了。</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>TLB(translation lookaside buffer)，快表，当cpu要访问一个虚拟地址&#x2F;线性地址时，CPU会首先根据虚拟地址的高20位（20是x86特定的，不同架构有不同的值）在TLB中查找。如果是表中没有相应的表项，称为TLB miss，需要通过访问慢速RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以后对同一线性地址的访问，直接从TLB表项中获取物理地址即可，称为TLB hit。</p><p>听起来和我们在计算机组成原理中学过的cache十分相似，事实上，我们可以把TLB看作位于内存中的页表的cahce。</p><p><strong>TLB硬件结构</strong></p><p>每一个 TLB 表项都有 64 位，其中高 32 位是 Key，低 32 位是 Data。</p><p>EntryHi、EntryLo都是CP0中的寄存器，分别对应TLB的Key与Data，二者结构如下</p><p>Key（EntryHi）</p><ul><li><p>VPN：Virtual Page Number</p><ul><li>当 <strong>TLB</strong> 缺失（CPU 发出虚拟地址，欲在 TLB 中查找物理地址但未查到）时，<strong>EntryHi</strong> 中的 <strong>VPN</strong> 自动（由硬件）填充为对应虚拟地址的虚页号。 </li><li>当需要填充或检索 TLB 表项时，软件需要将 VPN 段填充为对应的虚拟地址</li></ul></li><li><p>ASID：Address Space IDentifier</p><ul><li>用于区分不同的地址空间。查找 <strong>TLB</strong> 表项时，除了需要提供 <strong>VPN</strong>，还需要提供 <strong>ASID</strong>（同一虚拟地址在不同的地址空间中通常映射到不同的物理地址）。</li></ul></li></ul><p>Data（EntryLo）</p><ul><li>PFN：Physical Frame Number<ul><li>软件通过填写 <strong>PFN</strong>，随后使用 <strong>TLB</strong> 写指令，才将此时的 <strong>Key</strong> 与 <strong>Data</strong>写入 <strong>TLB</strong> 中。</li></ul></li><li>N：Non-cachable。当该位置高时，后续的物理地址访存将不通过 cache。 </li><li>D：Dirty。事实上是可写位。当该位置高时，该地址可写；否则任何写操作都将引发 TLB 异常。</li><li>V：Valid。如果该位为低，则任何访问该地址的操作都将引发 TLB 异常。</li><li>G：Global。</li></ul><p>事实上，TLB构建了一个映射，*&lt;* VPN*,* ASID <em>&gt;<strong>→</strong>&lt;* PFN*,* N*,* D*,* V*,* G *&gt;</em></p><p><strong>软件操作TLB的流程</strong></p><ol><li><p>填写 CP0 寄存器。</p></li><li><p>使用 TLB 相关指令。</p></li></ol><h3 id="多级页表与页目录自映射"><a href="#多级页表与页目录自映射" class="headerlink" title="多级页表与页目录自映射"></a>多级页表与页目录自映射</h3><p>如果页表与页目录没有被映射到进程的地址空间，4GB的地址空间均映射到进程内存需要4MB空间存放页表，4KB空间存放页目录。</p><p>在MOS中，页表和页目录都得到了映射，也就是说，在1024个页表之中有一个页表所对应的4MB是这1024个页表所占用的空间。而这一特殊页表就是页目录，因此，只需要4MB即可容纳页表和页目录。</p><p><strong>自映射目录的页目录项的地址</strong></p><p>在MOS中，将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000（共4MB）区域，这4MB的起始位置对应着页目录第一个页目录项，0x7fc00000这一地址对应第（0x7fc00000 &gt;&gt; 12）个页表项，该页表项相对于页表基地址的偏移为（0x7fc00000 &gt;&gt; 12）* 4，即0x1ff000，故页目录基地址为0x7fdff000。该项对应第（0x1ff000 &gt;&gt; 12）个页目录项，相对于页目录基地址为（0x1ff000 &gt;&gt; 12）* 4，即0x7fdff7fc。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/11/hello-world/"/>
    <url>/2022/04/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
